# What makes a good student?
(the following are a series of compiled notes that I have taken from various conversations with Gordon).
At the entry level of [Watch and Code®](https://www.watchandcode.com), the biggest predictor of future ability as a programmer is limited mostly by the following:

- Counter-intuitively, not the amount of time it takes to learn or to complete a task. The completion is more important than the time taken, unless there are other mitigating factors like work deadlines. Placing a time limit or time expectation on a task, or even a course, just adds an extra dimension of stress that is not necessary.

- Attitude towards learning: does the student exhibit an inclination towards curiosity, frustration tolerance and persistence? These tend to be the types of people that become successful programmers.

- Attitude towards mistakes: how quickly can people learn to tolerate mistakes? Learning to program and programming itself is essentially a continual adjustment to new information, new contexts and new types of problems. As a result, blocks to progress are not only frequent but the norm. Knowing what to do in these situations is paramount and has as much to do with managing your internal environment as it does with your raw programming ability.

- Willingness to question assumptions: whilst this is a skill that gets refined over time, there has to be a willingness to be actively engaged in the learning process. The student who actively probes into their coding and learning process learns much more than the one that doesn't. A good example would be when reading MDN documentation. If example code is provided, probing into that code using a console or editor can reveal as much useful information. Looking at code and generating multiple perspectives - like looking at light through a prism - can be a fruitful way to look at problems.

- A demonstrated and continual refinement in the ability to ask clearer questions.

## Successful students tend to:

- Code consistently over long periods of time, everyday if they can and indefinitely into the future. A good developer doesn’t ever reach a point of complete learning nor should you want to.

- Know how to ask great questions, both of themselves and others. If you can’t ask good questions, you can’t get good responses. See my article here: [How to be great at asking questions?](https://medium.com/@gordon_zhu/how-to-be-great-at-asking-questions-e37be04d0603)

- Use their time wisely and focus on depth of understanding as opposed to ‘vanity metrics’: shiny apps, time to complete a particular section or challenge etc.

- Realise that their fastest path is to use Watch and Code exclusively until they have exhausted all the available material (but here’s the thing – by the time you get here, if you have applied yourself diligently, you will be on your way to becoming your own teacher).

- Utilise the resources like office hours (free for everyone), our Slack channel (premium only), and daily accountability meetings (premium only) when they get stuck, instead of just giving up. The students that do their best to solve problems independently and only reach out for help if needed learn the fastest.

- Take time to answer questions from others in the community, as they realise that every question furthers their own understanding. Teaching is one of the most effective ways to learn something.

- Reflect on what has worked and what has not worked, using this information to change their decisions and behaviour accordingly. I tell people to go onto the Premium content only if they feel Practical Javascript was among the most useful things they have ever done. If not, they should continue to do what was more useful.

## Unsuccessful Students tend to:

- Mostly as a result of the marketing of large companies, hold tightly to the belief that most things in the programming industry will not help you much, if at all. This is particularly true of the courses that offer jobs within a defined period of time (normally three months). This is the same principle as expecting to get great results from nutritional supplements without exercise, weight loss drugs or infomercial exercise equipment yet wonder why they are not in shape. What is most perplexing is these types of people tend to just move to the next product, rather than consider their effectiveness of their strategy.

- Lack the patience to methodically debug and troubleshoot issues. Few people have the patience to do this, but it is absolutely necessary to becoming a good developer. Beginners are particularly prone to becoming frustrated and mistaking painful experiences as a sign of failure. These students give up without learning to build their tolerance for frustration, or don’t use the resources to get unstuck (office hours, Slack, online meetings etc).

- Are focused more on getting a job than getting better at programming. Once you are truly good at programming, getting a job is likely to follow.

- Prefer to skim over topics because they think finishing lessons (equivalent to collecting ‘badges’ or ‘points’ elsewhere) are the real indicator of progress. Finishing lessons by itself doesn’t indicate anything.

- Spread their efforts too thin, try to learn too many things; as a result these students typically achieve very little and give up in frustration due to the amount of time invested for such little pay off.

- Don’t realise that it depends more on you as an individual than the right course. Watch and Code is a tool that can help you succeed, and I believe it is the best or otherwise I would not be doing it. But even then it cannot, by itself, make you into a success. Only you can really do that.
It might help to think of Watch and Code like a gym. I believe Watch and Code is one of the best gyms out there, but unless you attend regularly (ideally everyday), train hard and make the most out of your membership, you are unlikely to transform into what you want to become.

## Extreme casing: compare & contrast

- Most things in life can be testing by 100% vs 0% cases. The coding example is best suited regarding assumptions. At one end of the scale, you can assume that 100% of your ideas are right. This never occurs in programming and jumping over our assumptions is the number one cause of bugs. The 0% end of this scale is to assume that ALL of your assumptions are wrong. Whilst this might not be true, operating from this place without letting it contribute to anxiety (which re-emphasises the importance of a strong problem solving process) equates to the ability to generate more questions. Generally geniuses in whatever field have tended towards the 0% side in this respect; they had the willingness to ask questions that nobody else saw.

- Another example might be with say, fasting. I think there is a lot that can be learned by deliberately and systematically going to the extremes. Gorging in this instance would be the 100% test case: you learn something strong about hunger and satiation there. Fasting is the 0% case - you learn something equally powerful, opposite but complementary about hunger and satiation from temporary deprivation. The middle -and optimal - way is, by definition, somewhere in between those two. But the polarity of contrasts helps you to clarify any errors in your assumptions and fine tune the bullshit detector.

## The Art of Focus

- Where possible, minimise physical distractions. Reaching for smart phones or internet browsers can act as an easy route into procrastination and deteriorates the ability to concentrate over time.

- The more distractions present, the harder it becomes to get a measure of whether whatever you are doing is an effective use of your time. This generally applied to what you are applying your coding time to as well.

- You can download the MDN documentation at [dev docs](https://devdocs.io) for offline access if you want to restrict internet access during working hours.

- When consulting tutorials or documentation for information, specificity is important. What do you want to know, why do you want to know it and what can you safely ignore to get to that point faster?

- Programmers spend lots of time reading code like lawyers spend lots of time reading legal cases. These documents never become 'easy' but over time proficiency is acquired. Top level lawyers are not spending time on legal tutorials.
